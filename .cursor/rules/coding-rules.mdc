---
description: 
globs: *.ts,*.vue
alwaysApply: false
---
# Nuxt Coding principals

Dont do any types writing for fetch api calls, its to much.

Embrace Auto-Imports: Nuxt 3 automatically scans and imports components, composables (like useState, useFetch), and utilities from dedicated directories (components/, composables/, utils/, server/utils/). Rely heavily on this feature. Avoid manual imports for these items to keep your <script setup lang="ts"> blocks cleaner and reduce boilerplate code.

Utilize TypeScript Pragmatically: Nuxt 3 has first-class TypeScript support. While auto-imports and type inference handle many cases, explicitly type component props, complex data structures, function arguments/return values, and especially API responses. This improves code reliability, maintainability, and developer experience (better autocompletion), without needing excessive annotations everywhere.

Typicaly when we fetch something from an api we use $fetch

A utility looks like this, always use that style to call functions in a utility:

useAi().chat(event, "name cool context")

Nuxt i18n localizsation files in i18n/locales/de.json, i18n/locales/de.json
the structure of those file is components -> name -> key value

to get the locale 
const { locale } = useI18n();

on pages/ we do SEO with useHead()

Per-Component Translations
Inline your translation messages within your components.
If you'd like to define translations per-page or per-component you can take advantage of the i18n custom block.

You can now define translations using i18n custom blocks in your Vue files:
example
page.vue

<script setup lang="ts">
const { t } = useI18n({
  useScope: 'local'
})
</script>

<template>
  <p>{{ t('hello') }}</p>
</template>

<i18n lang="json">
{
  "en": {
    "hello": "hello world!"
  },
  "ja": {
    "hello": "こんにちは、世界!"
  }
}
</i18n>

